<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
   <meta name="KEYWORDS" content="multitasking, multithreading, proces, vlakno, thread, deadlock, starvation">
   <meta name="GENERATOR" content="Mozilla/4.6 [en] (Win95; I) [Netscape]">
</head>
<body>

<h2>
Multitasking & Multithreading</h2>

<h3>
Úvod</h3>
Multitasking (nebo také "multi-tasking", "multi-processing", "multiprogramming",
"concurrency") je technika pou¾ívaná operaèními systémy pro vyu¾ívání jednoho
procesoru více nezávislými procesy. To pøiná¹í jak nìkteré výhody, tak
samozøejmì i jisté nevýhody.
<ul>Nejdøíve tedy klady:
<li>
umo¾òuje kdykoli pøejít k jinému programu, ani¾ bychom byli nuceni pøeru¹ovat
rozdìlanou práci</li>

<li>
usnadòuje implementaci èinností, které musí probíhat paralelnì, jako napøíklad
správa poèítaèové sítì</li>

<li>
jednotlivé programy mohou lépe spolupracovat, neomezují se pouze na výmìnu
souboru, ale mohou navzájem ovlivòovat svoji èinnost</li>

<li>
umo¾òuje realizaci multiu¾ivatelského systému</li>

<li>
umo¾òuje lep¹í vyu¾ití kapacity výpoèetního systému</li>

<br> 
<p> 
<p> Za hlavní nevýhody jsou pova¾ovány tyto:
<li>
¹patnì navr¾ený systém mù¾e pøi bìhu vìt¹ího mno¾ství programù negativnì
ovlivnit funkènost toho programu, se kterým u¾ivatel právì pracuje. To
se projeví napø. extrémním zpomalením, zvý¹ením doby odezvy na u¾ivatelský
pøíkazy a podobnì. Problém pøedev¹ím u kooperativního multitaskingu</li>

<li>
realizace multitaskingu se neobejde bez správy procesù a ta má nìjakou
vlastní re¾ii - spotøebovává procesorový èas. V krajním pøípadì mù¾e dojít
a¾ k zahlcení systému, kdy ve¹kerý nebo alespoò naprostá vìt¹ina procesorového
èasu je spotøebovávána na re¾ii. Hrozí pøedev¹ím u preemptivního multitaskingu.</li>

<li>
realizace Multitaskingového operaèního systému je slo¾itìj¹í a tudí¾ i
vìt¹ina firem si za nìj nechá více zaplatit (zlatou vyjímkou je Linux).
Takový systém má také vìt¹í nároky na hardware poèítaèe (vìt¹í RAM, rychlej¹í
procesor, více místa na disku, více.....). To je také uvádìno jako jeden
z dùvodù proè v dobì, kdy u¾ existovalo mno¾ství kvalitních a spolehlivých
multitaskingových operaèních systému byl stále nejpou¾ívanìj¹í jednoúlohový
MS-DOS. Zde je ov¹em nutno poznamenat, ¾e napøíklad multitaskingový OS
EPOC po¾adoval pøi minimální konfiguraci jen 512kB operaèní pamìti a procesor
NEC V30 s taktem 3,84 MHz!!</li>

<li>
pokud není OS spojen s dostateèným systémem zabezpeèení, zvy¹uje se riziko
ztráty dat. A to v pøípadì, ¾e chyba jednoho procesu zpùsobí zhroucení
celého OS (ukázkovým pøíkladem mohou být Windows 3.11, ale bohu¾el i verze
pozdìj¹í, i kdy¾ u¾ v men¹í míøe).</li>
</ul>
První multitaskingové operaèní systémy byly vytvoøeny zaèátkem 60. let.
Byly to OS na velkých sálových poèítaèích. Na poèítaèích typu PC se zaèali
pou¾ívat pomìrnì nedávno.
<h3>
Realizace multitaskingu</h3>
Vìt¹ina dne¹ních poèítaèù je osazena pouze jedním procesorem. Procesy samozøejmì
nemohou na jednom procesoru být zpracovávány spoleènì. OS tedy musí zajistit,
aby procesor zpracovávání jednotlivých procesù støídal v krátkých èasových
intervalech, co¾ se u¾ivateli jeví jako souèasné zpracovávání úloh.
<br>Existují tøí hlavní zpùsoby jak toho dosáhnout:
<br>a) task switching
<br>b) cooperative multitasking
<br>c) pre-emptive multitasking
<h4>
Task switching</h4>
- pøepínání programù
<br>OS s pøepínáním programù je pøímým pøedchùdcem kooperativního multitaskingu.
Vznikl na interaktivních systémech na základì pomìrnì jednoduché úvahy:
nejzøetelnìj¹í výhodou multitaskingu pro u¾ivatele je mo¾nost pøejít z
jedné aplikace k druhé, bez nutnosti ukonèení práce. Pøepínání programù
je dosa¾eno tzv. vzájemným voláním, co¾ není vlastnost pøímo OS, ale jednotlivých
programù. Ty mohou umo¾nit spu¹tìní jiného programu a práci s ním, po ukonèení
tohoto programu se obnoví stav pùvodního programu. Vzájemné volání bylo
roz¹íøeno zejména u programù pro Apple Macintosh a dnes se s ním setkáme
i u programù pod MS-DOS (tam se ale obvykle nevolá pøímo program, ale pøíkazový
interpret). Existují dvì skupiny OS s pøepínáním programù:
<ul>
<li>
systémy s omezeným pøepínáním: umo¾òuje pøepínat mezi hlavním programem
a nìkolika speciálními programy - accessories (pomùcky). Ty jsou vytvoøeny
zvlá¹tním zpùsobem právì pro pøepínání a deklarují se pøi startu OS.</li>

<li>
systémy s neomezeným pøepínáním umo¾òují spu¹tìní nìkolika bì¾ných programù
a pøepínání mezi nimi.</li>
</ul>
Pokud pøecházíme od jednoho programu k druhému, chceme vlastnì tento program
pøeru¹it takovým zpùsobem, abychom mohli jeho bìh po nìjakém èase obnovit.
Musíme tedy dùle¾ité informace ulo¾it nìkam na vnìj¹í pamì». To by znamenalo
obrovské mno¾ství informací - obsah celé operaèní pamìti, obsah registrù
procesoru, nastavení rùzných zaøízení, stav pomocných procesorù (blitter,
kanály) atd. Takové øe¹ení by bylo znaènì neefektivní a v nìkterých pøípadech
i nemo¾né. Obsah operaèní pamìti se neukládá, ale pouze se zajistí, aby
èást, kterou daný proces vyu¾ívá, nemohla být pou¾ita jiným procesem. Málokterý
program vyu¾ívá v¹echna zaøízení, bylo by proto naprosto zbyteèné, starat
se o v¹echny. Program mù¾e být také po¾ádán, aby se dostal pøed pøeru¹ením
do pøedem definovaného stavu: ukonèil práci s periferními zaøízeními i
s obrazovkou (kanály, blitter), ukonèil výpoèty v pohyblivé øadové èárce
(koprocesor) atp. Dále mù¾eme program pøimìt, aby po obnovení práce nespoléhal
na obsah registrù procesoru. Zbude pak jen naprosté minimu údajù, které
musíme ulo¾it - pouze nastavení zásobníku a obsah obrazovky. Tyto údaje
jsou ulo¾eny pro v¹echny momentálnì rozpracované úlohy v tabulce, která
se nazývá kontext. Programy, které mají v pamìti svùj kontext se nazývají
procesy (task).
<br>Pokud je tøeba pøepnout z aktivního procesu na jiný proces, napøíklad
na základì nìjakého signálu u¾ivatele, OS vyèká a¾ proces zavolá slu¾bu,
kterou oznamuje, ¾e je v "pøeru¹itelném" stavu (to je ka¾dý proces povinen
pravidelnì dìlat, a OS mají tuto slu¾bu obvykle kombinovanou s jinými slu¾bami
OS (èasto napø. pøeru¹ení od klávesnice), aby ji program nemohl obejít).
Pak OS ulo¾í do tabulky na místo odpovídající dosud aktivnímu procesu adresu
vr¹ku jeho zásobníku (pøeète ji z patøièného registru procesoru). Nakonec
systém zjistí z tabulky adresu zásobníku nového procesu a zavede ji do
patøièného registru procesoru. Ukonèí slu¾bu a od té chvíle bì¾í nový proces
- do¹lo k pøepnutí kontextu (context switch) - byl odebrán procesor starému
procesu a pøidìlen procesu novému.
<br>Podrobnìji: Tìsnì pøed pøepnutím kontextu obsahuje zásobník procesu
èíslo 1 (aktivní) na vrcholku návratovou adresu pro návrat ze systémové
slu¾by zpìt do kódu procesu. Døíve, ne¾ dojde k návratu, v¹ak pøepnutí
kontextu zmìní zásobník. Ve chvíli návratu je tedy aktivní zásobník procesu
èíslo2, na jeho¾ vrcholu je samozøejmì také návratová adresa, ale tentokrát
do procesu èíslo 2 - a tam se systémová slu¾ba vrátí.
<br>Pøi vytváøení procesu je vytvoøen tomuto procesu zásobník, na který
je ulo¾ena adresa jeho první instrukce a adresa tohoto zásobníku je ulo¾ena
do kontextu.
<br> 
<br> 
<h4>
Cooperative multitasking</h4>
- kooperativní multitasking
<br>Jeho princip vychází pøímo z mechanizmu pøepínání programù. Tam mohlo
dojít k pøepnutí kontextu pouze na ¾ádost u¾ivatele. To vedlo k tomu ¾e,
znaèné mno¾ství procesorového èasu bylo nevyu¾ito. To si tvùrci kooperativního
multitaskingu uvìdomovali a byli vedeni snahou tento nevyu¾itý èas pøidìlit
jinému procesu. V pøípadì, ¾e aktivní proces napøíklad èeká na stisk klávesy,
mù¾e být spu¹tìn proces jiný. Poté co tento proces zavolá pøeru¹ovací slu¾bu
vrátí se procesor ke zpracovávání pùvodního procesu. Pokud ten stále nedostal
signál od klávesnice bude se situace opakovat. Proces èekající, v tomto
pøípadì na stisk klávesnice, se nazývá proces na popøedí (foreground),
procesy na pozadí (background) jsou pak ty, které vyu¾ívají procesorový
èas, který by jinak byl promarnìn. Takovýto multitasking byl pou¾it napø.
u Windows 3.x.
<br>Kooperativní multitasking má v¹echny výhody, které poskytuje systém
s neomezeným pøepínáním programù. Navíc lépe vyu¾ívá procesor.
<br>Vyznaèuje se ale nìkterými záva¾nými nevýhodami:
<ul>
<li>
zpomalení procesu na popøedí se odvíjí od toho jak je proces bì¾ící na
pozadí naprogramován.</li>

<li>
nelze pou¾ít pro realizaci paralelních úloh</li>

<li>
mù¾e dojít k situaci ¾e pøeru¹ovací slu¾ba procesu na pozadí nebude nikdy
zavolána (nekoneèná smyèka). Dojde pak k zablokování nejen tohoto procesu,
ale celého systému. S tím je samozøejmì spojena velmi reálná mo¾nost ztráty
dat ostatních spu¹tìných aplikací. Kooperativní multitasking tedy není
a nemù¾e být z tohoto hlediska bezpeèný.</li>

<li>
programování aplikací pro kooperativní multitasking je omezeno mno¾stvím
konvencí. Ve¹kerá èasovì nároènìj¹í èinnost programu musí být rozdìlena
na krat¹í úseky oddìlené voláním "pøeru¹ovací" slu¾by. To vedlo k tomu,
¾e øada firem oznaèila své programy "foreground only" èím¾ je tento systém
degradován pouze na systém s neomezeným pøepínáním</li>

<li>
celkovì není realizace kooperativního multitaskingu jednodu¹¹í ne¾ preemptivního</li>

<br> 
<p> 
<br> 
<br> </ul>

<h4>
Pre-emptive multitasking</h4>
- preemptivní multitasking
<br>Hlavní nevýhodou pøedchozího øe¹ení je tedy to, ¾e ka¾dý proces musí
s OS spolupracovat. Toto omezení odstraòuje právì preemptivní multitasking.
Ten umo¾òuje pøeru¹ení kteréhokoli procesu na kterémkoli místì, ani¾ by
proces sám do toho musel nìjakým zpùsobem zasahovat. U kooperativního multitaskingu
proces zaji¹»uje svoji nezávislost pøi svém opìtovném spu¹tìní na registrech
procesoru, koprocesoru, stavu blitteru, I/O procesorù,... Není ov¹em mo¾né
toto v¹echno ulo¾it do kontextu, je nutné to nìjakým rozumným zpùsobem
obejít. Do kontextu se ulo¾í pouze stav procesoru a pøípadnì koprocesoru
a s ostatními prvky systému je povoleno pracovat jen jedinému procesu.
Jejich stav v pøípadì pøeru¹ení procesu se tedy nemusí ukládat, proto¾e
jiný proces s nimi nemù¾e pracovat. S tím se ov¹em objevuje nebezpeèí zablokování
procesù. Proto moderní OS zakazují pou¾ívání systémových prostøedkù v¹em
procesùm kromì speciálnì vyhrazených systémových procesù. Takový proces
se nazývá server a udr¾uje si informace o svých klientech, kterým poskytuje
slu¾by umo¾òující jim nepøímo vyu¾ívat dané zaøízení.
<br>Zpracovávání procesù se velmi rychle støídá (øádovì desítky a¾ stovky
milisekund) a tak vzniká dojem paralelního zpracování. Velikost intervalu,
po jeho¾ uplynutí dochází ke støídání procesù se nazývá èasové kvantum
(time-slice). Po vypr¹ení èasového kvanta tedy dojde k zastavení jednoho
procesu a spu¹tìní dal¹ího. Støídání úloh je obvykle realizováno pomocí
vnìj¹ího pøeru¹ení od èítaèe, který èítá hodinové pulsy a po uplynutí pøedem
definované doby, tzv. základního èasového intervalu - tiku velikosti jednotek
a¾ desítek milisekund, generuje ¾ádost o pøeru¹ení. OS pøi ka¾dém tiku
provede nìkteré nutné servisní úkoly (napø. aktualizace systémového èasu)
a pokud zjistí, ¾e procesu vypr¹elo èasové kvantum, pøeru¹í jeho èinnost.
To se nazývá preempcí.
<br>Preemptivní multitasking umo¾òuje nastavení priorit jednotlivých procesù.
<br><b>Pøidìlování procesoru</b>
<br>Pøidìlování procesoru procesùm provádí dva moduly OS: plánovaè (scheduler)
a dispeèer (dispatcher). Scheduler z fronty èekajících procesù ve swapovací
oblasti vybírá procesy, které budou nahrány do pamìti a tak pøipraveny
ke spu¹tìní dispeèerem. Dispeèer pak vybírá podle urèitých kriterií z fronty
procesù, které jsou pøipraveny ke spu¹tìní ten, který bude opravdu spu¹tìn.
<p> <b>Uzavírání zdrojù</b>
<br>Za jistých okolností potøebují procesy k systémovým prostøedkùm výluèný
pøístup. Pokud proces získal výluèný pøístup øíkáme, ¾e zdroj uzavøel.
To je nutné, aby nedo¹lo k èasové závislosti procesù. K èasové závislosti
procesu s jinými procesy mù¾e dojít jen tehdy, kdy¾ proces vykonává urèitou
èást svého kódu, kterou nazýváme kritickou oblastí. Musíme tedy zajistit,
aby v urèitý èasový okam¾ik byl v kritické oblasti pouze jeden z procesù.
Této podmínce se øíká podmínka vzájemného vylouèení (mutual exclusion).
Vzájemné vylouèení se realizuje tak, ¾e první proces, který chce se zdrojem
manipulovat, zdroj uzavøe. Po uzavøení zdroje tento proces vstupuje do
kritické oblasti a ostatní procesy musí poèkat, dokud tento proces kritickou
oblast neopustí. Jakmile proces kritickou oblast opustí, do kritické oblasti
mù¾e vstoupit dal¹í proces. Øíkáme také, ¾e proces zdroj otevøel (uvolnil).
<br>Uzavírání zdrojù tedy není nic jiného ne¾ realizace podmínky vzájemného
vylouèení procesù.
<p> <b>Realizace vzájemného vylouèení</b>
<br>Vzájemné vylouèení lze realizovat nejrùznìj¹ími zpùsoby. Ty se nejèastìji
dìlí do dvou kategorií a to z hlediska stavu, ve kterém se nacházejí procesy
èekající na vstup do kritické oblasti. Ty jsou buï ve stavu aktivního èekání
nebo ve stavu zablokování.
<br>Zatímco procesy ve stavu aktivního èekání neustále testují splnìní
urèité podmínky, aby mohly vstoupit do kritické oblasti, a tím spotøebovávají
procesorový èas (jsou zaøazovány dispatcherem ke zpracování), tak pøi øe¹ení,
pøi kterém jsou procesy ve stavu zablokování je jednodu¹e proces, který
se neúspì¹nì pokusil vstoupit do kritické oblasti, zablokován a tudí¾ není
dispatcherem nadále zaøazován ke zpracování. Poté co jiný proces opustí
danou kritickou oblast je tento proces probuzen, dispatcher jej èasem zaøadí
ke zpracování a proces mù¾e do kritické oblasti vstoupit. Nedochází tedy
ke zbyteènému spotøebovávání procesorového èasu.
<br>Oba dva zpùsoby se mohou øe¹it pomocí zámku nebo semaforu.
<p> <b>Vzájemné vylouèení realizované zámkem</b>
<br>Zámek je procesy sdílená promìnná. Procesy ji mohou nastavovat na rùzné
hodnoty. Pokud ji nìkterý z procesù nastaví na nenulovou hodnotu, oznamuje
tím ostatním procesùm to, ¾e vstoupil do kritické oblasti. Pokud je hodnota
zámku nulová, znamená to, ¾e se ¾ádný z procesù v kritické oblasti nenachází.
Kdyby ov¹em tento systém pracoval následovnì mohlo by se stát, ¾e do kritické
oblasti vstoupí i více procesù: 1. Na poèátku bude zámek = 0.
<br>2. Proces testuje hodnotu zámku. Je-li jeho hodnota nulová pokraèuje
bodem 3. Není-li tomu tak provádí opakované testování hodnoty zámku dokud
se hodnota zámku nezmìní na 0 (do kritické oblasti nevstoupí).
<br>3. Nastaví zámek na 1 a vstoupí do kritické oblasti. .
<br>4. Tìsnì pøed výstupem z kritické oblasti nastaví zámek = 0
<p> Pokud by ov¹em byl proces A mezi body 2. a 3. pøeru¹en preempcí
a jiný proces B se pokusil vstoupit do této kritické oblasti a nevystoupil
by z ní do dal¹ího volání procesu A vstoupily by do kritické oblasti oba
dva procesy. Tomu je nutné nìjakým zpùsobem zabránit. Jsou pou¾ívané tyto
tøi mo¾nosti:
<ul>
<li>
bìhem ètení a nastavení zámku se zaká¾e pøeru¹ení od hodin - není to pøíli¹
vhodné øe¹ení a ani se nepou¾ívá</li>

<li>
pou¾ije se speciální instrukce, která jak otestuje hodnotu zámku tak pøípadnì
nastaví i jeho novou hodnotu - ne v¹echny procesory takovou instrukci mají</li>

<li>
softwarové øe¹ení - pou¾ívá bì¾ných strojových instrukcí, ale je nároènìj¹í
na èas Pøi pou¾ití zámku jsou procesy èekající na vstup do kritické oblasti
ve stavu aktivního èekání. Proto pou¾ívání techniky zámku není nejvhodnìj¹í.</li>
</ul>
Nìkdy se technika zámku pozmìòuje tak, ¾e proces po zji¹tìní, ¾e zámek
je uzavøen, po¾ádá operaèní systém o zablokování na urèitou dobu a opìtovný
test zámku provede a¾ po svém probuzení. To sice omezuje plýtvání procesorovým
èasem, ale na druhé stranì mù¾e podstatnì prodlou¾it dobu èekání procesu
(nebo» uvolnìný zdroj si mù¾e mezitím uzavøít jiný proces) .
<br><b>Vzájemné vylouèení realizované semaforem</b>
<br>Toto øe¹ení je vhodnìj¹í. Semafor je promìnná nabývající hodnoty 0,1,2,......,
n. Semafory musí být implementovány operaèním systémem jako slu¾ba systému.
<br>Pomocí semaforu lze implementovat vzájemné vylouèení následujícím zpùsobem:
<br>1. Na poèátku je semafor (s) nastaven napø. na hodnotu 1 (s=1)
<br>2. Pøed vstupem do kritické oblasti je testována hodnota s. Pokud je
vìt¹í jak 0 (s != 0) sní¾í se o 1 (s = s - 1). Pokud je s = 0 je proces
pozastaven. Po svém probuzení a opìtovném spu¹tìní dokonèí operaci, tj.
sní¾í hodnotu s o 1 (s = s - 1)
<br>3. Pøed opu¹tìním kritické oblasti proces zvý¹í s o 1 (s = s + 1).
Jeden z pozastavených procesù je probuzen
<p> <b>Uváznutí procesù - deadlock</b>
<br>V multitaskingových operaèních systémech mù¾e pøi uzavírání zdrojù
snadno dojít k tak zvanému uváznutí procesù. Dojde k tomu jestli¾e dva
èi více procesù na sebe navzájem èekají. (viz. obr.)
<center><img SRC="images/deadl.gif" ALT="Deadlock" NOSAVE height=287 width=334>
<br>Obr.deadlock</center>
Proces A si uzavøel Zdroj I. a Proces B si uzavøel Zdroj II. Poté se sna¾í
Proces A uzavøít Zdroj II., ale ten je uzavøen Procesem B. OS proces A
tedy zablokuje. Proces B se sna¾í uzavøít Zdroj I. a je OS také zablokován.
<br>Øe¹ením mù¾e být tzv. úplné vyhrazení prostøedkù tzn., ¾e pøi spu¹tìní
procesu budou zablokovány ve¹keré zdroje, které by mohl tento proces bìhem
své èinnosti potøebovat. Je zøejmé ¾e, takové øe¹ení je znaènì neefektivní
a vede k sní¾ení prùchodnosti systému. Dal¹í mo¾ností je, ¾e v pøípadì,
kdy je zdroj, který proces potøebuje, uzavøen u¾ jiným procesem, tak proces
uvolní v¹echny ostatní zdroje, které si pro sebe uzavøel a po¾ádá OS o
pozastavení. Po urèité dobì je proces opìt probuzen a pokusí se uzavøít
si pro sebe zdroje, které potøebuje pro pøedepsanou èinnost. Pøi takovéto
strategii nemù¾e nikdy dojít k uváznutí procesù, ale procesy se mou dostat
do stavu, který se nazývá starvation - stárnutí procesù (viz. ní¾e).
<br>Jiným øe¹ením je, ¾e na mno¾inì zdrojù {Rn}je definováno uspoøádání
R1<R2<.....<Rn a zdroje jsou pøidìlovány ka¾dému procesu v poøadí
definovaným tímto uspoøádáním, v alokaèním grafu zdrojù nemù¾e vzniknout
cyklus . Nemù¾e proto dojít k uváznutí procesù. To se nazývá Hierarchické
pøidìlování prostøedkù. V pøedchozím pøíkladì by to znamenalo, ¾e by se
Proces B sna¾il nejdøíve uzavøít Zdroj I., ale vzhledem k tomu, ¾e ten
by ji¾ byl vyhrazen Procesu A do¹lo by k zablokování Procesu B. Proces
A by si pak bez problému uzavøel i Zdroj II., dokonèil svoji èinnost a
oba zdroje uvolnil. Proces B by pak udìlal toté¾. Proces uzavírá zdroje
v poøadí tak, jak je potøebuje. Jakmile jeden ze zdrojù nemù¾e uzavøít,
uvolní v¹echny dosud uzavøené zdroje, po¾ádá operaèní systém o zablokování
na urèitou dobu a po èase se o uzavøení zdrojù pokusí znovu. Je mo¾ná i
kombinace tìchto dvou øe¹ení.
<br>této strategii nemù¾e dojít k uváznutí procesù, procesy se v¹ak mohou
dostat do stavu, který se nazývá stárnutí procesù.
<p> <b>Stárnutí procesù - starvation</b>
<br>Procesy sice neèekají na otevøení urèitého zdroje, jsou v omezené míøe
stále aktivní, ale nepodaøí se jim uzavøít si v¹echny potøebné zdroje.
Pøedpokládejme, ¾e jsou dva procesy a dva zdroje. Oba procesy pro úspì¹né
dokonèení své èinnosti potøebuje v¾dy dva zdroje. Oba dva si tedy uzavøou
v¾dy jeden zdroj. Po urèité dobì se procesy pokusí uzavøít druhý zdroj.
Ten je ale ji¾ vyhrazen jinému procesu a procesy tedy uvolní ji¾ uzavøené
zdroje a po¾ádají OS o pøeru¹ení. Po jejich opìtovném spu¹tìní se celá
situace mù¾e opakovat.
<center><img SRC="images/starv.gif" ALT="Starvation" NOSAVE height=219 width=397>
<br>Obr. Starvation</center>
Vyhnout se tomu dá napø. tak, ¾e doba, po kterou budou jednotlivé procesy
pozastaveny , bude rùznì dlouhá.
<h2>
Multithreading</h2>
Je to schopnost programu sám sebe vìtvit. Program se dìlí na tzv. vlákna
(threads of executions), která se zdají bì¾et souèasnì. To má výhodu v
tom, ¾e pøi provádìní nìjaké nároènìj¹í a dlouhotrvající práce (napø. ukládání
dlouhého souboru) se aplikace "nezasekne". Programátor zpravidla vytvoøí
jedno vlákno frontové, které vyrobí v¹echna okna, jedno nebo více vláken
bezfrontových, která poèítají. Je známé tzv. pravidlo 1/10 sekundy "Cokoli
trvá déle ne¾ 1/10 sekundy, mìlo by se provádìt v novém bezfrontovém vláknu."
<br>Zatímco u multitaskingu jsou jednotlivé procesy zcela oddìlené (vlastní
pamì»,...) pøi multithreadingu v¹echna vlákna (jedné aplikace) sdílejí
stejné systémové zdroje - pamì», soubory, globální promìnné, ka¾dé vlákno
má svùj zásobník, tj. automatické promìnné jsou pro ka¾dé vlákno zvlá¹».
<br>Ve Windows 3.x ka¾dá bì¾ící aplikace je jedna úloha. OS pøidìluje CPU
tìmto úlohám pou¾íváním kooperativního multitaskingu a spoléhá na aplikace,
¾e umo¾ní pøedání procesorového èasu jiné úloze. Ve Win32 se u¾ nemluví
o úlohách, ale o procesech a vláknech. Proces se mù¾e skládat z jednoho
èi více vláken. Proces a vlákna jsou pøeru¹ovány preempcí. Ve Windows 3.x
byla ka¾dá úloha pouze jedním vláknem. Program byl provádìn od zaèátku
do konce. Ve Win32 proces vzniká jako jedno vlákno, které mù¾e vytvoøit
vlákna dal¹í bì¾ící na pozadí (formátování diskety, provádìní slo¾itého
výpoètu, vyhledávání,....). Tìmto vláknùm je procesorový èas pøedáván zcela
nezávisle, jako samostatným programùm.
<p> <b>Thread Scheduling</b>
<br>Rozhodnutí kterému vláknu pøidìlit procesorový èas a na jak dlouho
je pro OS slo¾itý proces. V prvé øadì bere Scheduler ohled na priority
jednotlivých vláken. Ve Windows 95 a NT je mo¾no pøidìlit ka¾dému vláknu
hodnotu priority od 0 do 31, èím vy¹¹í èíslo, tím vy¹¹í priorita. Hodnota
priority 31 je reservována pro extrémnì krizová vlákna (napø. získávání
dat v reálném èase) zatímco hodnota 0 je pou¾ívána OS pro témìø zbyteèná
vlákna, která se spou¹tìjí pouze v pøípadì, ¾e je procesorový èas nevyu¾íván.
Nejpou¾ívanìj¹í jsou hodnoty od 7 do 11.
<br>Po nìkolika milisekundách scheduler vyhodnotí situaci a pøedá procesorový
èas vláknu s nejvy¹¹í prioritou. Pokud jsou dvì èi více vláken se stejnou
prioritou je spu¹tìno to od jeho¾ posledního provádìní ubìhlo nejvíce èasu.
Vlákna s vy¹¹í prioritou jsou tedy provádìny pøed vlákny s ni¾¹í prioritou
a vlákna s nízkou prioritou nikdy nepøeru¹í vlákna s vysokou prioritou.
Neznamená to ale, ¾e vlákno s ni¾¹í prioritou nebude nikdy spu¹tìno. Jsou-li
dvì vlákna A a B s prioritou 10 a 9 bude provádìno vlákno A. Pokud má vlákno
A prázdnou frontu zpráv tzn., ¾e dokud nepøijde dal¹í zpráva nemá nic na
práci, je toto vlákno pozastaveno a mù¾e být spu¹tìno vlákno B. Pozastavenému
vláknu není pøidìlován procesorový èas dokud neobdr¾í nìjakou zprávu, která
ho probudí a pøeru¹í preempcí vlákno B, je¾ bylo doposud provádìno. Mnoho
vláken tak stráví znaèné mno¾ství èasu ve stavu èekání na nìjakou vstupní
událost.
<BR><BR>
<A HREF= "http://www.geocities.com/SiliconValley/Cable/1135/index.html"> index</A>
<br><BR> 
<div align=right><font size=-2>William Wollis 1999</font></div>
</body>
</html>